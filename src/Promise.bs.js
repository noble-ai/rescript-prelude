// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Void from "./Void.bs.js";
import * as $$Array from "./Array.bs.js";
import * as Curry from "rescript/lib/es6/curry.js";
import * as Tuple from "./Tuple.bs.js";
import * as Timeout from "./Timeout.bs.js";

function make(prim) {
  return new Promise(Curry.__2(prim));
}

var $$return = ((val) => Promise.resolve(val));

var reject = ((val) => Promise.reject(val));

var map = ((p, fn) => p.then(fn));

function $$const(p, a) {
  return map(p, (function (param) {
                return a;
              }));
}

var bind = ((p, fn) => p.then(fn));

function join(a) {
  return bind(a, (function (x) {
                return x;
              }));
}

function tap(p, fn) {
  return bind(p, (function (a) {
                Curry._1(fn, a);
                return $$return(a);
              }));
}

function tapBind(p, fn) {
  return bind(p, (function (a) {
                var p = Curry._1(fn, a);
                return map(p, (function (param) {
                              return a;
                            }));
              }));
}

var finallyVoid = tap;

function sequence(ins, fn) {
  return $$Array.reduce(ins, (function (p, a) {
                return bind(p, (function (bs) {
                              return map(Curry._1(fn, a), (function (b) {
                                            return $$Array.concat(bs, [b]);
                                          }));
                            }));
              }), $$return([]));
}

function toResult(p) {
  return bind(p, (function (a) {
                  return $$return({
                              TAG: /* Ok */0,
                              _0: a
                            });
                })).catch(function (err) {
              var message = err.message;
              return $$return({
                          TAG: /* Error */1,
                          _0: message
                        });
            });
}

function sleep(time) {
  return new Promise((function (resolve, _reject) {
                Void.$$void(Timeout.set((function (param) {
                            resolve("ding");
                          }), time));
              }));
}

function delay(ms, p) {
  return map(Promise.all(Tuple.Tuple2.make(sleep(ms), p)), Tuple.snd2);
}

export {
  make ,
  $$return ,
  reject ,
  map ,
  $$const ,
  bind ,
  join ,
  tap ,
  tapBind ,
  finallyVoid ,
  sequence ,
  toResult ,
  sleep ,
  delay ,
}
/* No side effect */
