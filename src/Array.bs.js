// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as $$Option from "./Option.bs.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Caml_splice_call from "rescript/lib/es6/caml_splice_call.js";

function getUnsafe(prim0, prim1) {
  return prim0[prim1];
}

function length(prim) {
  return prim.length;
}

var clone = ((x) => [...x]);

function unsafeSet(arr, index, x) {
  var arr$1 = clone(arr);
  arr$1[index] = x;
  return arr$1;
}

function map(prim0, prim1) {
  return prim0.map(Curry.__1(prim1));
}

function mapi(prim0, prim1) {
  return prim0.map(Curry.__2(prim1));
}

function forEach(prim0, prim1) {
  prim0.forEach(Curry.__1(prim1));
}

function forEachi(prim0, prim1) {
  prim0.forEach(Curry.__2(prim1));
}

function filter(prim0, prim1) {
  return prim0.filter(Curry.__1(prim1));
}

function includes(prim0, prim1) {
  return prim0.includes(prim1);
}

function joinWith(prim0, prim1) {
  return prim0.join(prim1);
}

function find(prim0, prim1) {
  return Caml_option.undefined_to_opt(prim0.find(Curry.__1(prim1)));
}

function reduce(prim0, prim1, prim2) {
  return prim0.reduce(Curry.__2(prim1), prim2);
}

function reducei(prim0, prim1, prim2) {
  return prim0.reduce(Curry.__3(prim1), prim2);
}

function indexOf(prim0, prim1) {
  return prim0.indexOf(prim1);
}

function reverseInPlace(prim) {
  return prim.reverse();
}

function every(prim0, prim1) {
  return prim0.every(Curry.__1(prim1));
}

function pushMany(prim0, prim1) {
  return Caml_splice_call.spliceObjApply(prim0, "push", [prim1]);
}

function push(prim0, prim1) {
  return prim0.push(prim1);
}

function spliceInPlace(prim0, prim1, prim2, prim3) {
  return Caml_splice_call.spliceObjApply(prim0, "splice", [
              prim1,
              prim2,
              prim3
            ]);
}

function findIndex(prim0, prim1) {
  return prim0.findIndex(Curry.__1(prim1));
}

function keepMap(arr, fn) {
  var v = [];
  arr.forEach(function (x) {
        var y = Curry._1(fn, x);
        if (y !== undefined) {
          v.push(Caml_option.valFromOption(y));
          return ;
        }
        
      });
  return v;
}

var range = ((i) => [...Array(i).keys()]);

var rangeInclusive = ((i) => [...Array(i + 1).keys()]);

function rangeInclusive$1(n) {
  if (n >= 0) {
    return rangeInclusive(n);
  } else {
    return [];
  }
}

function flatten(arr) {
  return arr.flatMap(function (prim) {
              return prim;
            });
}

function $$return(a) {
  return [a];
}

function $$const(xs, b) {
  return xs.map(function (param) {
              return b;
            });
}

function toIndices(__x) {
  return __x.map(function (param, i) {
              return i;
            });
}

function all(prim0, prim1) {
  return prim0.every(Curry.__1(prim1));
}

function alli(prim0, prim1) {
  return prim0.every(Curry.__2(prim1));
}

function some(prim0, prim1) {
  return prim0.some(Curry.__1(prim1));
}

function somei(prim0, prim1) {
  return prim0.some(Curry.__2(prim1));
}

function slice(prim0, prim1, prim2) {
  return prim0.slice(prim1, prim2);
}

function sliceFrom(prim0, prim1) {
  return prim0.slice(prim1);
}

function head(__x) {
  return Belt_Array.get(__x, 0);
}

function tail(arr) {
  return arr.slice(1);
}

function stem(arr) {
  return arr.slice(0, -1);
}

function last(arr) {
  return Belt_Array.get(arr, arr.length - 1 | 0);
}

function take(arr, $$int) {
  return arr.slice(0, $$int);
}

function zipAdjacent(arr) {
  return arr.slice(1).map(function (a, i) {
              return [
                      arr[i],
                      a
                    ];
            });
}

function findEq(arr, x) {
  return Caml_option.undefined_to_opt(arr.find(function (y) {
                  return Caml_obj.equal(y, x);
                }));
}

function findBy(arr, fn, b) {
  return Caml_option.undefined_to_opt(arr.find(function (y) {
                  return Caml_obj.equal(Curry._1(fn, y), b);
                }));
}

function first(arr, fn) {
  return $$Option.bind(Caml_option.undefined_to_opt(arr.find(function (y) {
                      return $$Option.isSome(Curry._1(fn, y));
                    })), fn);
}

function partitionIndexEvenOdd(arr) {
  var odd = arr.filter(function (param, i) {
        return i % 2 === 0;
      });
  var even = arr.filter(function (param, i) {
        return i % 2 !== 0;
      });
  return {
          even: even,
          odd: odd
        };
}

function cross(a, b) {
  return a.flatMap(function (a) {
              return b.map(function (b) {
                          return [
                                  a,
                                  b
                                ];
                        });
            });
}

function splitAt(arr, i) {
  var a = arr.slice(0, i);
  var b = arr.slice(i, arr.length);
  return [
          a,
          b
        ];
}

function catOptions(arr) {
  return keepMap(arr, (function (prim) {
                return prim;
              }));
}

function keepBind(a, fn) {
  var arr = a.map(function (a) {
        return $$Option.bind(a, fn);
      });
  return keepMap(arr, (function (prim) {
                return prim;
              }));
}

function intercalate(arr, i) {
  var length = arr.length;
  if (length <= 1) {
    return arr;
  } else {
    return arr.flatMap(function (a) {
                  return [
                          a,
                          i
                        ];
                }).slice(0, length + (length - 1 | 0) | 0);
  }
}

function intercalateWithGenerator(arr, gen) {
  var length = arr.length;
  if (length <= 1) {
    return arr;
  } else {
    return arr.flatMap(function (a, idx) {
                  return [
                          a,
                          Curry._1(gen, idx)
                        ];
                }).slice(0, length + (length - 1 | 0) | 0);
  }
}

function tap(a, fn) {
  Curry._1(fn, a);
  return a;
}

function tapMap(a, fn) {
  a.forEach(Curry.__1(fn));
  return a;
}

function concat(a, b) {
  return a.concat(b);
}

function append(acc, a) {
  return acc.concat([a]);
}

function isEmpty(arr) {
  return arr.length === 0;
}

function replace(arr, el, index) {
  if (index < 0) {
    return arr;
  }
  if (index >= arr.length) {
    return arr;
  }
  var begin = arr.slice(0, index);
  var end = arr.slice(index + 1 | 0);
  return begin.concat([el], end);
}

function insert(arr, el, index) {
  if (arr.length === 0 && index === 0) {
    return [el];
  }
  if (index < 0) {
    return arr;
  }
  if (index >= arr.length) {
    return arr;
  }
  var begin = arr.slice(0, index);
  var end = arr.slice(index);
  return begin.concat([el], end);
}

function remove(arr, index) {
  if (arr.length === 0 && index === 0) {
    return [];
  }
  if (index < 0) {
    return arr;
  }
  if (index >= arr.length) {
    return arr;
  }
  var begin = arr.slice(0, index);
  var end = arr.slice(index + 1 | 0);
  return begin.concat(end);
}

function generateCombinations(arr, beginOpt, size) {
  var begin = beginOpt !== undefined ? beginOpt : [];
  if (size === 0) {
    return [begin];
  } else {
    return arr.flatMap(function (v, i) {
                var begin$1 = begin.concat([v]);
                var length = arr.length;
                var arr$1 = arr.slice(i + 1 | 0, length + (length - 1 | 0) | 0);
                return generateCombinations(arr$1, begin$1, size - 1 | 0);
              });
  }
}

var get = Belt_Array.get;

var getBy = Belt_Array.getBy;

var getExn = Belt_Array.getExn;

var getIndexBy = Belt_Array.getIndexBy;

var reverse = Belt_Array.reverse;

var join = flatten;

var partition = Belt_Array.partition;

export {
  get ,
  getUnsafe ,
  getBy ,
  getExn ,
  getIndexBy ,
  length ,
  reverse ,
  clone ,
  unsafeSet ,
  map ,
  mapi ,
  forEach ,
  forEachi ,
  filter ,
  includes ,
  joinWith ,
  find ,
  reduce ,
  reducei ,
  indexOf ,
  reverseInPlace ,
  every ,
  pushMany ,
  push ,
  spliceInPlace ,
  findIndex ,
  keepMap ,
  range ,
  rangeInclusive$1 as rangeInclusive,
  flatten ,
  join ,
  $$return ,
  $$const ,
  toIndices ,
  all ,
  alli ,
  some ,
  somei ,
  slice ,
  sliceFrom ,
  head ,
  tail ,
  stem ,
  last ,
  take ,
  zipAdjacent ,
  findEq ,
  findBy ,
  first ,
  partition ,
  partitionIndexEvenOdd ,
  cross ,
  splitAt ,
  catOptions ,
  keepBind ,
  intercalate ,
  intercalateWithGenerator ,
  tap ,
  tapMap ,
  concat ,
  append ,
  isEmpty ,
  replace ,
  insert ,
  remove ,
  generateCombinations ,
}
/* No side effect */
